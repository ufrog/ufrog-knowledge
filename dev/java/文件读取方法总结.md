# 文件读取方法总结

## 一、打印加载地址
最近在做一些文件读取修改等等的功能，发现文件的读取捉摸不透，有些读取结果让人匪夷所思，所以就找了几个常用的读取文件方式，进行了一些实验。

先看下面的代码：

```java
public class Tests {

    @Test
    public void printPath() throws MalformedURLException {
        System.out.println("Current thread class loader: " + Thread.currentThread().getContextClassLoader().getResource("/test.docx"));             // 当前线程类加载器
        System.out.println("Current thread class loader without /: " + Thread.currentThread().getContextClassLoader().getResource("test.docx"));    // 当前线程类加载器，不带斜杠
        System.out.println("System class loader: " + ClassLoader.getSystemClassLoader().getResource("/test.docx"));                                 // 系统类加载器
        System.out.println("System class loader without /: " + ClassLoader.getSystemClassLoader().getResource("test.docx"));                        // 系统类加载器，不带斜杠
        System.out.println("Tests class loader: " + Tests.class.getClassLoader().getResource("/test.docx"));                                        // 当前类类加载器
        System.out.println("File util class loader: " + FileUtil.class.getClassLoader().getResource("/test.docx"));                                 // 其他包的类类加载器
        System.out.println("File util: " + FileUtil.class.getResource("/test.docx"));                                                               // 其他包的类直接读取
        System.out.println("Tests: " + Tests.class.getResource("/test.docx"));                                                                      // 当前类直接读取
        System.out.println("Paths: " + Paths.get("/test.docx").toUri().toURL());                                                                    // JDK提供的Paths类读取
        System.out.println("Class loader: " + ClassLoader.getSystemResource("/test.docx"));                                                         // 系统类加载器直接读取
        System.out.println("In the jar: " + Tests.class.getResource("/docx4j_version.properties"));                                                 // 当前类直接读取其他包内文件
        System.out.println("In the jar by class loader: " + Tests.class.getClassLoader().getResource("docx4j_version.properties"));                 // 当前类类加载器读取其他包内文件
    }
}
```

我们的「test.docx」是在「classpath」下的，「docx4j_version.properties」是在「docx4j-core-8.3.8.jar」包里的。得到了如下的结果：

```
Current thread class loader: null
Current thread class loader without /: file:/C:/Users/RS30554/IdeaProjects/ufrog-common-v1.1.x/ufrog-common-office/target/test-classes/test.docx
System class loader: null
System class loader without /: file:/C:/Users/RS30554/IdeaProjects/ufrog-common-v1.1.x/ufrog-common-office/target/test-classes/test.docx
Docx4j tests class loader: null
File util class loader: null
File util: file:/C:/Users/RS30554/IdeaProjects/ufrog-common-v1.1.x/ufrog-common-office/target/test-classes/test.docx
Docx4j tests: file:/C:/Users/RS30554/IdeaProjects/ufrog-common-v1.1.x/ufrog-common-office/target/test-classes/test.docx
Paths: file:/C:/test.docx
Class loader: null
In the jar: jar:file:/C:/Users/RS30554/.m2/repository/org/docx4j/docx4j-core/8.3.8/docx4j-core-8.3.8.jar!/docx4j_version.properties
In the jar by class loader: jar:file:/C:/Users/RS30554/.m2/repository/org/docx4j/docx4j-core/8.3.8/docx4j-core-8.3.8.jar!/docx4j_version.properties
```

## 二、总结
1. 所有使用「ClassLoader」加载的文件，即使是在根目录也不需要加「/」，可以认为「ClassLoader」是从根目录开始读取的；
2. 用类直接加载是需要加「/」的，我们可以看下代码：

```java
public final class Class<T> implements java.io.Serializable,
                              GenericDeclaration,
                              Type,
                              AnnotatedElement {
    
    /**
     * Finds a resource with a given name.  The rules for searching resources
     * associated with a given class are implemented by the defining
     * {@linkplain ClassLoader class loader} of the class.  This method
     * delegates to this object's class loader.  If this object was loaded by
     * the bootstrap class loader, the method delegates to {@link
     * ClassLoader#getSystemResource}.
     *
     * <p> Before delegation, an absolute resource name is constructed from the
     * given resource name using this algorithm:
     *
     * <ul>
     *
     * <li> If the {@code name} begins with a {@code '/'}
     * (<tt>'&#92;u002f'</tt>), then the absolute name of the resource is the
     * portion of the {@code name} following the {@code '/'}.
     *
     * <li> Otherwise, the absolute name is of the following form:
     *
     * <blockquote>
     *   {@code modified_package_name/name}
     * </blockquote>
     *
     * <p> Where the {@code modified_package_name} is the package name of this
     * object with {@code '/'} substituted for {@code '.'}
     * (<tt>'&#92;u002e'</tt>).
     *
     * </ul>
     *
     * @param  name name of the desired resource
     * @return      A  {@link java.net.URL} object or {@code null} if no
     *              resource with this name is found
     * @since  JDK1.1
     */
    public java.net.URL getResource(String name) {
        name = resolveName(name);
        ClassLoader cl = getClassLoader0();
        if (cl==null) {
            // A system class.
            return ClassLoader.getSystemResource(name);
        }
        return cl.getResource(name);
    }
    
    /**
     * Add a package name prefix if the name is not absolute Remove leading "/"
     * if name is absolute
     */
    private String resolveName(String name) {
        if (name == null) {
            return name;
        }
        if (!name.startsWith("/")) {
            Class<?> c = this;
            while (c.isArray()) {
                c = c.getComponentType();
            }
            String baseName = c.getName();
            int index = baseName.lastIndexOf('.');
            if (index != -1) {
                name = baseName.substring(0, index).replace('.', '/')
                    +"/"+name;
            }
        } else {
            name = name.substring(1);
        }
        return name;
    }
}
```

这里抽取了「Class」的「getResource」方法，里面又用到了「resolveName」方法。首先我们可以看到其实「getResource」最终还是调用「ClassLoader」的「getResource」方法，
而唯一不同的是在调用前先处理了一下路径。我们看到如果文件路径以「/」开头，会直接将「/」去掉。但是不是「/」开头的情况，则会将当前类的路径拼到文件路径上，
也就是说类的「getResource」方法是可以直接读类包路径下的文件。

3. 「Paths」就直接读取磁盘下的文件，适合读取非项目内指定目录地址的文件。
4. 最后是关于读取「jar」包内的文件。按照我们的方法是可以把文件地址读出来，但是这个地址无法加载到文件，但是可以读出「URL」对象，然后「openStream」是可以打开文件的。

读取文件基本就这几种情况，如果搞清楚了，那在获取文件地址和读取文件流的时候就没有太大的问题。